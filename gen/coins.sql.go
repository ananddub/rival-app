// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: coins.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCoins = `-- name: AddCoins :exec
UPDATE wallets SET coins = coins + $2, updated_at = NOW() WHERE user_id = $1
`

type AddCoinsParams struct {
	UserID int64       `json:"user_id"`
	Coins  pgtype.Int8 `json:"coins"`
}

func (q *Queries) AddCoins(ctx context.Context, arg AddCoinsParams) error {
	_, err := q.db.Exec(ctx, addCoins, arg.UserID, arg.Coins)
	return err
}

const createCoinPackage = `-- name: CreateCoinPackage :one
INSERT INTO coin_packages (name, coins, price, bonus_coins, is_active)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, coins, price, bonus_coins, is_active, created_at
`

type CreateCoinPackageParams struct {
	Name       string         `json:"name"`
	Coins      int64          `json:"coins"`
	Price      pgtype.Numeric `json:"price"`
	BonusCoins pgtype.Int8    `json:"bonus_coins"`
	IsActive   pgtype.Bool    `json:"is_active"`
}

func (q *Queries) CreateCoinPackage(ctx context.Context, arg CreateCoinPackageParams) (CoinPackage, error) {
	row := q.db.QueryRow(ctx, createCoinPackage,
		arg.Name,
		arg.Coins,
		arg.Price,
		arg.BonusCoins,
		arg.IsActive,
	)
	var i CoinPackage
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Coins,
		&i.Price,
		&i.BonusCoins,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const createCoinPurchase = `-- name: CreateCoinPurchase :one
INSERT INTO coin_purchases (user_id, package_id, coins_received, amount_paid, payment_status, payment_id) 
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, user_id, package_id, coins_received, amount_paid, payment_status, payment_id, created_at
`

type CreateCoinPurchaseParams struct {
	UserID        int64          `json:"user_id"`
	PackageID     int64          `json:"package_id"`
	CoinsReceived int64          `json:"coins_received"`
	AmountPaid    pgtype.Numeric `json:"amount_paid"`
	PaymentStatus pgtype.Text    `json:"payment_status"`
	PaymentID     pgtype.Text    `json:"payment_id"`
}

func (q *Queries) CreateCoinPurchase(ctx context.Context, arg CreateCoinPurchaseParams) (CoinPurchase, error) {
	row := q.db.QueryRow(ctx, createCoinPurchase,
		arg.UserID,
		arg.PackageID,
		arg.CoinsReceived,
		arg.AmountPaid,
		arg.PaymentStatus,
		arg.PaymentID,
	)
	var i CoinPurchase
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PackageID,
		&i.CoinsReceived,
		&i.AmountPaid,
		&i.PaymentStatus,
		&i.PaymentID,
		&i.CreatedAt,
	)
	return i, err
}

const createCoinTransaction = `-- name: CreateCoinTransaction :one
INSERT INTO coin_transactions (user_id, coins, type, reason) VALUES ($1, $2, $3, $4) RETURNING id, user_id, coins, type, reason, created_at
`

type CreateCoinTransactionParams struct {
	UserID int64       `json:"user_id"`
	Coins  int64       `json:"coins"`
	Type   string      `json:"type"`
	Reason pgtype.Text `json:"reason"`
}

func (q *Queries) CreateCoinTransaction(ctx context.Context, arg CreateCoinTransactionParams) (CoinTransaction, error) {
	row := q.db.QueryRow(ctx, createCoinTransaction,
		arg.UserID,
		arg.Coins,
		arg.Type,
		arg.Reason,
	)
	var i CoinTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Coins,
		&i.Type,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const deductCoins = `-- name: DeductCoins :exec
UPDATE wallets SET coins = coins - $2, updated_at = NOW() WHERE user_id = $1 AND coins >= $2
`

type DeductCoinsParams struct {
	UserID int64       `json:"user_id"`
	Coins  pgtype.Int8 `json:"coins"`
}

func (q *Queries) DeductCoins(ctx context.Context, arg DeductCoinsParams) error {
	_, err := q.db.Exec(ctx, deductCoins, arg.UserID, arg.Coins)
	return err
}

const getAllCoinTransactions = `-- name: GetAllCoinTransactions :many
SELECT id, user_id, coins, type, reason, created_at FROM coin_transactions WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetAllCoinTransactions(ctx context.Context, userID int64) ([]CoinTransaction, error) {
	rows, err := q.db.Query(ctx, getAllCoinTransactions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoinTransaction
	for rows.Next() {
		var i CoinTransaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Coins,
			&i.Type,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoinPackages = `-- name: GetCoinPackages :many
SELECT id, name, coins, price, bonus_coins, is_active, created_at FROM coin_packages WHERE is_active = true ORDER BY price ASC
`

func (q *Queries) GetCoinPackages(ctx context.Context) ([]CoinPackage, error) {
	rows, err := q.db.Query(ctx, getCoinPackages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoinPackage
	for rows.Next() {
		var i CoinPackage
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Coins,
			&i.Price,
			&i.BonusCoins,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoinTransactions = `-- name: GetCoinTransactions :many
SELECT id, user_id, coins, type, reason, created_at FROM coin_transactions WHERE user_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type GetCoinTransactionsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetCoinTransactions(ctx context.Context, arg GetCoinTransactionsParams) ([]CoinTransaction, error) {
	rows, err := q.db.Query(ctx, getCoinTransactions, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoinTransaction
	for rows.Next() {
		var i CoinTransaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Coins,
			&i.Type,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCoins = `-- name: GetUserCoins :one
SELECT coins FROM wallets WHERE user_id = $1
`

func (q *Queries) GetUserCoins(ctx context.Context, userID int64) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, getUserCoins, userID)
	var coins pgtype.Int8
	err := row.Scan(&coins)
	return coins, err
}

const updatePurchaseStatus = `-- name: UpdatePurchaseStatus :exec
UPDATE coin_purchases SET payment_status = $2 WHERE id = $1
`

type UpdatePurchaseStatusParams struct {
	ID            int64       `json:"id"`
	PaymentStatus pgtype.Text `json:"payment_status"`
}

func (q *Queries) UpdatePurchaseStatus(ctx context.Context, arg UpdatePurchaseStatusParams) error {
	_, err := q.db.Exec(ctx, updatePurchaseStatus, arg.ID, arg.PaymentStatus)
	return err
}
