// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rewards.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addReferralReward = `-- name: AddReferralReward :one
INSERT INTO referral_rewards (referrer_id, referred_user_id)
VALUES ($1, $2)
RETURNING id, referrer_id, referred_user_id, coins_earned, created_at
`

type AddReferralRewardParams struct {
	ReferrerID     int64 `json:"referrer_id"`
	ReferredUserID int64 `json:"referred_user_id"`
}

func (q *Queries) AddReferralReward(ctx context.Context, arg AddReferralRewardParams) (ReferralReward, error) {
	row := q.db.QueryRow(ctx, addReferralReward, arg.ReferrerID, arg.ReferredUserID)
	var i ReferralReward
	err := row.Scan(
		&i.ID,
		&i.ReferrerID,
		&i.ReferredUserID,
		&i.CoinsEarned,
		&i.CreatedAt,
	)
	return i, err
}

const claimDailyReward = `-- name: ClaimDailyReward :one
INSERT INTO daily_rewards (user_id, day)
VALUES ($1, $2)
ON CONFLICT (user_id, day) DO NOTHING
RETURNING id, user_id, day, claimed_at, created_at
`

type ClaimDailyRewardParams struct {
	UserID int64 `json:"user_id"`
	Day    int32 `json:"day"`
}

func (q *Queries) ClaimDailyReward(ctx context.Context, arg ClaimDailyRewardParams) (DailyReward, error) {
	row := q.db.QueryRow(ctx, claimDailyReward, arg.UserID, arg.Day)
	var i DailyReward
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Day,
		&i.ClaimedAt,
		&i.CreatedAt,
	)
	return i, err
}

const claimUserReward = `-- name: ClaimUserReward :one
INSERT INTO user_rewards (user_id, reward_id, claimed, claimed_at)
VALUES ($1, $2, true, NOW())
ON CONFLICT (user_id, reward_id) 
DO UPDATE SET claimed = true, claimed_at = NOW()
RETURNING id, user_id, reward_id, claimed, claimed_at, created_at
`

type ClaimUserRewardParams struct {
	UserID   int64 `json:"user_id"`
	RewardID int64 `json:"reward_id"`
}

func (q *Queries) ClaimUserReward(ctx context.Context, arg ClaimUserRewardParams) (UserReward, error) {
	row := q.db.QueryRow(ctx, claimUserReward, arg.UserID, arg.RewardID)
	var i UserReward
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RewardID,
		&i.Claimed,
		&i.ClaimedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createNewReward = `-- name: CreateNewReward :one
INSERT INTO rewards (title, description, type, coins, is_active)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, title, description, type, coins, money, is_active, created_at
`

type CreateNewRewardParams struct {
	Title       string      `json:"title"`
	Description pgtype.Text `json:"description"`
	Type        string      `json:"type"`
	Coins       pgtype.Int8 `json:"coins"`
	IsActive    pgtype.Bool `json:"is_active"`
}

func (q *Queries) CreateNewReward(ctx context.Context, arg CreateNewRewardParams) (Reward, error) {
	row := q.db.QueryRow(ctx, createNewReward,
		arg.Title,
		arg.Description,
		arg.Type,
		arg.Coins,
		arg.IsActive,
	)
	var i Reward
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Type,
		&i.Coins,
		&i.Money,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getAllActiveRewards = `-- name: GetAllActiveRewards :many
SELECT id, title, description, type, coins, money, is_active, created_at FROM rewards WHERE is_active = true ORDER BY created_at DESC
`

func (q *Queries) GetAllActiveRewards(ctx context.Context) ([]Reward, error) {
	rows, err := q.db.Query(ctx, getAllActiveRewards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reward
	for rows.Next() {
		var i Reward
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.Coins,
			&i.Money,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClaimedDailyRewards = `-- name: GetClaimedDailyRewards :many
SELECT id, user_id, day, claimed_at, created_at FROM daily_rewards WHERE user_id = $1 ORDER BY day
`

func (q *Queries) GetClaimedDailyRewards(ctx context.Context, userID int64) ([]DailyReward, error) {
	rows, err := q.db.Query(ctx, getClaimedDailyRewards, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DailyReward
	for rows.Next() {
		var i DailyReward
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Day,
			&i.ClaimedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReferralCount = `-- name: GetReferralCount :one
SELECT COUNT(*) FROM referral_rewards WHERE referrer_id = $1
`

func (q *Queries) GetReferralCount(ctx context.Context, referrerID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getReferralCount, referrerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRewardById = `-- name: GetRewardById :one
SELECT id, title, description, type, coins, money, is_active, created_at FROM rewards WHERE id = $1
`

func (q *Queries) GetRewardById(ctx context.Context, id int64) (Reward, error) {
	row := q.db.QueryRow(ctx, getRewardById, id)
	var i Reward
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Type,
		&i.Coins,
		&i.Money,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getUserRewards = `-- name: GetUserRewards :many
SELECT id, user_id, reward_id, claimed, claimed_at, created_at FROM user_rewards WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetUserRewards(ctx context.Context, userID int64) ([]UserReward, error) {
	rows, err := q.db.Query(ctx, getUserRewards, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserReward
	for rows.Next() {
		var i UserReward
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RewardID,
			&i.Claimed,
			&i.ClaimedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
