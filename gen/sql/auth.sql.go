// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth.sql

package schema

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createJWTSession = `-- name: CreateJWTSession :exec
INSERT INTO
    jwt_sessions (
        user_id,
        token_hash,
        refresh_token_hash,
        expires_at
    )
VALUES ($1, $2, $3, $4)
`

type CreateJWTSessionParams struct {
	UserID           pgtype.Int8      `json:"user_id"`
	TokenHash        string           `json:"token_hash"`
	RefreshTokenHash pgtype.Text      `json:"refresh_token_hash"`
	ExpiresAt        pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) CreateJWTSession(ctx context.Context, arg CreateJWTSessionParams) error {
	_, err := q.db.Exec(ctx, createJWTSession,
		arg.UserID,
		arg.TokenHash,
		arg.RefreshTokenHash,
		arg.ExpiresAt,
	)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO
    users (
        email,
        password_hash,
        phone,
        name,
        profile_pic,
        firebase_uid,
        coin_balance,
        role,
        referral_code,
        referred_by
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10
    )
RETURNING
    id, email, password_hash, phone, name, profile_pic, firebase_uid, coin_balance, role, referral_code, referred_by, created_at, updated_at
`

type CreateUserParams struct {
	Email        string         `json:"email"`
	PasswordHash pgtype.Text    `json:"password_hash"`
	Phone        pgtype.Text    `json:"phone"`
	Name         string         `json:"name"`
	ProfilePic   pgtype.Text    `json:"profile_pic"`
	FirebaseUid  pgtype.Text    `json:"firebase_uid"`
	CoinBalance  pgtype.Numeric `json:"coin_balance"`
	Role         NullUserRole   `json:"role"`
	ReferralCode pgtype.Text    `json:"referral_code"`
	ReferredBy   pgtype.Int8    `json:"referred_by"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.Phone,
		arg.Name,
		arg.ProfilePic,
		arg.FirebaseUid,
		arg.CoinBalance,
		arg.Role,
		arg.ReferralCode,
		arg.ReferredBy,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Name,
		&i.ProfilePic,
		&i.FirebaseUid,
		&i.CoinBalance,
		&i.Role,
		&i.ReferralCode,
		&i.ReferredBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJWTSession = `-- name: GetJWTSession :one
SELECT id, user_id, token_hash, refresh_token_hash, expires_at, is_revoked, created_at
FROM jwt_sessions
WHERE
    token_hash = $1
    AND is_revoked = false
`

func (q *Queries) GetJWTSession(ctx context.Context, tokenHash string) (JwtSession, error) {
	row := q.db.QueryRow(ctx, getJWTSession, tokenHash)
	var i JwtSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.ExpiresAt,
		&i.IsRevoked,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, phone, name, profile_pic, firebase_uid, coin_balance, role, referral_code, referred_by, created_at, updated_at FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Name,
		&i.ProfilePic,
		&i.FirebaseUid,
		&i.CoinBalance,
		&i.Role,
		&i.ReferralCode,
		&i.ReferredBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, phone, name, profile_pic, firebase_uid, coin_balance, role, referral_code, referred_by, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Name,
		&i.ProfilePic,
		&i.FirebaseUid,
		&i.CoinBalance,
		&i.Role,
		&i.ReferralCode,
		&i.ReferredBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByReferralCode = `-- name: GetUserByReferralCode :one
SELECT id, email, password_hash, phone, name, profile_pic, firebase_uid, coin_balance, role, referral_code, referred_by, created_at, updated_at FROM users WHERE referral_code = $1
`

func (q *Queries) GetUserByReferralCode(ctx context.Context, referralCode pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByReferralCode, referralCode)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Name,
		&i.ProfilePic,
		&i.FirebaseUid,
		&i.CoinBalance,
		&i.Role,
		&i.ReferralCode,
		&i.ReferredBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const revokeAllUserSessions = `-- name: RevokeAllUserSessions :exec
UPDATE jwt_sessions SET is_revoked = true WHERE user_id = $1
`

func (q *Queries) RevokeAllUserSessions(ctx context.Context, userID pgtype.Int8) error {
	_, err := q.db.Exec(ctx, revokeAllUserSessions, userID)
	return err
}

const revokeJWTSession = `-- name: RevokeJWTSession :exec
UPDATE jwt_sessions SET is_revoked = true WHERE token_hash = $1
`

func (q *Queries) RevokeJWTSession(ctx context.Context, tokenHash string) error {
	_, err := q.db.Exec(ctx, revokeJWTSession, tokenHash)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET
    name = $2,
    phone = $3,
    profile_pic = $4,
    updated_at = NOW()
WHERE
    id = $1
`

type UpdateUserParams struct {
	ID         int64       `json:"id"`
	Name       string      `json:"name"`
	Phone      pgtype.Text `json:"phone"`
	ProfilePic pgtype.Text `json:"profile_pic"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.ID,
		arg.Name,
		arg.Phone,
		arg.ProfilePic,
	)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET
    password_hash = $2,
    updated_at = NOW()
WHERE
    id = $1
`

type UpdateUserPasswordParams struct {
	ID           int64       `json:"id"`
	PasswordHash pgtype.Text `json:"password_hash"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}
