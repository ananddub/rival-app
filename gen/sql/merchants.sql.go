// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: merchants.sql

package schema

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActiveMerchants = `-- name: CountActiveMerchants :one
SELECT COUNT(*) FROM merchants WHERE is_active = true
`

func (q *Queries) CountActiveMerchants(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveMerchants)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMerchants = `-- name: CountMerchants :one
SELECT COUNT(*) FROM merchants
`

func (q *Queries) CountMerchants(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMerchants)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMerchant = `-- name: CreateMerchant :one
INSERT INTO merchants (
    name, email, phone, category, discount_percentage, is_active
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, name, email, password_hash, phone, category, discount_percentage, is_active, created_at, updated_at
`

type CreateMerchantParams struct {
	Name               string         `json:"name"`
	Email              string         `json:"email"`
	Phone              pgtype.Text    `json:"phone"`
	Category           pgtype.Text    `json:"category"`
	DiscountPercentage pgtype.Numeric `json:"discount_percentage"`
	IsActive           pgtype.Bool    `json:"is_active"`
}

func (q *Queries) CreateMerchant(ctx context.Context, arg CreateMerchantParams) (Merchant, error) {
	row := q.db.QueryRow(ctx, createMerchant,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.Category,
		arg.DiscountPercentage,
		arg.IsActive,
	)
	var i Merchant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Category,
		&i.DiscountPercentage,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMerchantAddress = `-- name: CreateMerchantAddress :one
INSERT INTO merchant_addresses (
    merchant_id, street, city, state, postal_code, country, latitude, longitude, is_primary
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, merchant_id, street, city, state, postal_code, country, latitude, longitude, is_primary, created_at, updated_at
`

type CreateMerchantAddressParams struct {
	MerchantID pgtype.Int8    `json:"merchant_id"`
	Street     pgtype.Text    `json:"street"`
	City       pgtype.Text    `json:"city"`
	State      pgtype.Text    `json:"state"`
	PostalCode pgtype.Text    `json:"postal_code"`
	Country    pgtype.Text    `json:"country"`
	Latitude   pgtype.Numeric `json:"latitude"`
	Longitude  pgtype.Numeric `json:"longitude"`
	IsPrimary  pgtype.Bool    `json:"is_primary"`
}

func (q *Queries) CreateMerchantAddress(ctx context.Context, arg CreateMerchantAddressParams) (MerchantAddress, error) {
	row := q.db.QueryRow(ctx, createMerchantAddress,
		arg.MerchantID,
		arg.Street,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.Latitude,
		arg.Longitude,
		arg.IsPrimary,
	)
	var i MerchantAddress
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Street,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOffer = `-- name: CreateOffer :one
INSERT INTO offers (
    merchant_id, title, description, discount_percentage, min_amount, max_discount, valid_from, valid_until
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, merchant_id, title, description, discount_percentage, min_amount, max_discount, is_active, valid_from, valid_until, created_at, updated_at
`

type CreateOfferParams struct {
	MerchantID         pgtype.Int8      `json:"merchant_id"`
	Title              string           `json:"title"`
	Description        pgtype.Text      `json:"description"`
	DiscountPercentage pgtype.Numeric   `json:"discount_percentage"`
	MinAmount          pgtype.Numeric   `json:"min_amount"`
	MaxDiscount        pgtype.Numeric   `json:"max_discount"`
	ValidFrom          pgtype.Timestamp `json:"valid_from"`
	ValidUntil         pgtype.Timestamp `json:"valid_until"`
}

func (q *Queries) CreateOffer(ctx context.Context, arg CreateOfferParams) (Offer, error) {
	row := q.db.QueryRow(ctx, createOffer,
		arg.MerchantID,
		arg.Title,
		arg.Description,
		arg.DiscountPercentage,
		arg.MinAmount,
		arg.MaxDiscount,
		arg.ValidFrom,
		arg.ValidUntil,
	)
	var i Offer
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Title,
		&i.Description,
		&i.DiscountPercentage,
		&i.MinAmount,
		&i.MaxDiscount,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllMerchants = `-- name: GetAllMerchants :many
SELECT id, name, email, password_hash, phone, category, discount_percentage, is_active, created_at, updated_at FROM merchants 
ORDER BY created_at DESC 
LIMIT $1 OFFSET $2
`

type GetAllMerchantsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllMerchants(ctx context.Context, arg GetAllMerchantsParams) ([]Merchant, error) {
	rows, err := q.db.Query(ctx, getAllMerchants, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Merchant
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.PasswordHash,
			&i.Phone,
			&i.Category,
			&i.DiscountPercentage,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantAddresses = `-- name: GetMerchantAddresses :many
SELECT id, merchant_id, street, city, state, postal_code, country, latitude, longitude, is_primary, created_at, updated_at FROM merchant_addresses 
WHERE merchant_id = $1 
ORDER BY created_at DESC
`

func (q *Queries) GetMerchantAddresses(ctx context.Context, merchantID pgtype.Int8) ([]MerchantAddress, error) {
	rows, err := q.db.Query(ctx, getMerchantAddresses, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MerchantAddress
	for rows.Next() {
		var i MerchantAddress
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Street,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Latitude,
			&i.Longitude,
			&i.IsPrimary,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantByEmail = `-- name: GetMerchantByEmail :one
SELECT id, name, email, password_hash, phone, category, discount_percentage, is_active, created_at, updated_at FROM merchants WHERE email = $1
`

func (q *Queries) GetMerchantByEmail(ctx context.Context, email string) (Merchant, error) {
	row := q.db.QueryRow(ctx, getMerchantByEmail, email)
	var i Merchant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Category,
		&i.DiscountPercentage,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMerchantByID = `-- name: GetMerchantByID :one
SELECT id, name, email, password_hash, phone, category, discount_percentage, is_active, created_at, updated_at FROM merchants WHERE id = $1
`

func (q *Queries) GetMerchantByID(ctx context.Context, id int64) (Merchant, error) {
	row := q.db.QueryRow(ctx, getMerchantByID, id)
	var i Merchant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Category,
		&i.DiscountPercentage,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMerchantCustomers = `-- name: GetMerchantCustomers :many
SELECT DISTINCT u.id, u.email, u.password_hash, u.phone, u.name, u.profile_pic, u.firebase_uid, u.coin_balance, u.role, u.referral_code, u.referred_by, u.created_at, u.updated_at FROM users u
JOIN transactions t ON u.id = t.user_id
WHERE t.merchant_id = $1
ORDER BY u.created_at DESC
LIMIT $2 OFFSET $3
`

type GetMerchantCustomersParams struct {
	MerchantID pgtype.Int8 `json:"merchant_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) GetMerchantCustomers(ctx context.Context, arg GetMerchantCustomersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getMerchantCustomers, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.Phone,
			&i.Name,
			&i.ProfilePic,
			&i.FirebaseUid,
			&i.CoinBalance,
			&i.Role,
			&i.ReferralCode,
			&i.ReferredBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantOffers = `-- name: GetMerchantOffers :many
SELECT id, merchant_id, title, description, discount_percentage, min_amount, max_discount, is_active, valid_from, valid_until, created_at, updated_at FROM offers 
WHERE merchant_id = $1 AND is_active = true
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetMerchantOffersParams struct {
	MerchantID pgtype.Int8 `json:"merchant_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) GetMerchantOffers(ctx context.Context, arg GetMerchantOffersParams) ([]Offer, error) {
	rows, err := q.db.Query(ctx, getMerchantOffers, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Offer
	for rows.Next() {
		var i Offer
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Title,
			&i.Description,
			&i.DiscountPercentage,
			&i.MinAmount,
			&i.MaxDiscount,
			&i.IsActive,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantTransactions = `-- name: GetMerchantTransactions :many
SELECT id, user_id, merchant_id, coins_spent, original_amount, discount_amount, final_amount, transaction_type, status, created_at FROM transactions 
WHERE merchant_id = $1 
ORDER BY created_at DESC 
LIMIT $2 OFFSET $3
`

type GetMerchantTransactionsParams struct {
	MerchantID pgtype.Int8 `json:"merchant_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) GetMerchantTransactions(ctx context.Context, arg GetMerchantTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getMerchantTransactions, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MerchantID,
			&i.CoinsSpent,
			&i.OriginalAmount,
			&i.DiscountAmount,
			&i.FinalAmount,
			&i.TransactionType,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantsByCategory = `-- name: GetMerchantsByCategory :many
SELECT id, name, email, password_hash, phone, category, discount_percentage, is_active, created_at, updated_at FROM merchants WHERE category = $1 AND is_active = true ORDER BY name
`

func (q *Queries) GetMerchantsByCategory(ctx context.Context, category pgtype.Text) ([]Merchant, error) {
	rows, err := q.db.Query(ctx, getMerchantsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Merchant
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.PasswordHash,
			&i.Phone,
			&i.Category,
			&i.DiscountPercentage,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOfferByID = `-- name: GetOfferByID :one
SELECT id, merchant_id, title, description, discount_percentage, min_amount, max_discount, is_active, valid_from, valid_until, created_at, updated_at FROM offers WHERE id = $1
`

func (q *Queries) GetOfferByID(ctx context.Context, id int64) (Offer, error) {
	row := q.db.QueryRow(ctx, getOfferByID, id)
	var i Offer
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Title,
		&i.Description,
		&i.DiscountPercentage,
		&i.MinAmount,
		&i.MaxDiscount,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveMerchants = `-- name: ListActiveMerchants :many
SELECT id, name, email, password_hash, phone, category, discount_percentage, is_active, created_at, updated_at FROM merchants WHERE is_active = true ORDER BY name
`

func (q *Queries) ListActiveMerchants(ctx context.Context) ([]Merchant, error) {
	rows, err := q.db.Query(ctx, listActiveMerchants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Merchant
	for rows.Next() {
		var i Merchant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.PasswordHash,
			&i.Phone,
			&i.Category,
			&i.DiscountPercentage,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMerchant = `-- name: UpdateMerchant :exec
UPDATE merchants SET
    name = $2,
    phone = $3,
    category = $4,
    discount_percentage = $5,
    is_active = $6,
    updated_at = NOW()
WHERE id = $1
`

type UpdateMerchantParams struct {
	ID                 int64          `json:"id"`
	Name               string         `json:"name"`
	Phone              pgtype.Text    `json:"phone"`
	Category           pgtype.Text    `json:"category"`
	DiscountPercentage pgtype.Numeric `json:"discount_percentage"`
	IsActive           pgtype.Bool    `json:"is_active"`
}

func (q *Queries) UpdateMerchant(ctx context.Context, arg UpdateMerchantParams) error {
	_, err := q.db.Exec(ctx, updateMerchant,
		arg.ID,
		arg.Name,
		arg.Phone,
		arg.Category,
		arg.DiscountPercentage,
		arg.IsActive,
	)
	return err
}

const updateOffer = `-- name: UpdateOffer :exec
UPDATE offers SET
    title = $2,
    description = $3,
    discount_percentage = $4,
    min_amount = $5,
    max_discount = $6,
    valid_from = $7,
    valid_until = $8,
    is_active = $9,
    updated_at = NOW()
WHERE id = $1
`

type UpdateOfferParams struct {
	ID                 int64            `json:"id"`
	Title              string           `json:"title"`
	Description        pgtype.Text      `json:"description"`
	DiscountPercentage pgtype.Numeric   `json:"discount_percentage"`
	MinAmount          pgtype.Numeric   `json:"min_amount"`
	MaxDiscount        pgtype.Numeric   `json:"max_discount"`
	ValidFrom          pgtype.Timestamp `json:"valid_from"`
	ValidUntil         pgtype.Timestamp `json:"valid_until"`
	IsActive           pgtype.Bool      `json:"is_active"`
}

func (q *Queries) UpdateOffer(ctx context.Context, arg UpdateOfferParams) error {
	_, err := q.db.Exec(ctx, updateOffer,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.DiscountPercentage,
		arg.MinAmount,
		arg.MaxDiscount,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.IsActive,
	)
	return err
}
