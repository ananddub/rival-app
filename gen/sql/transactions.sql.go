// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package schema

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCoinPurchase = `-- name: CreateCoinPurchase :one
INSERT INTO coin_purchases (
    user_id, amount, coins_received, payment_method, status
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, user_id, amount, coins_received, payment_method, payment_id, status, created_at
`

type CreateCoinPurchaseParams struct {
	UserID        pgtype.UUID    `json:"user_id"`
	Amount        pgtype.Numeric `json:"amount"`
	CoinsReceived pgtype.Numeric `json:"coins_received"`
	PaymentMethod pgtype.Text    `json:"payment_method"`
	Status        pgtype.Text    `json:"status"`
}

func (q *Queries) CreateCoinPurchase(ctx context.Context, arg CreateCoinPurchaseParams) (CoinPurchase, error) {
	row := q.db.QueryRow(ctx, createCoinPurchase,
		arg.UserID,
		arg.Amount,
		arg.CoinsReceived,
		arg.PaymentMethod,
		arg.Status,
	)
	var i CoinPurchase
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Amount,
		&i.CoinsReceived,
		&i.PaymentMethod,
		&i.PaymentID,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    user_id, merchant_id, coins_spent, original_amount, 
    transaction_type, status
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, merchant_id, coins_spent, original_amount, discount_amount, final_amount, transaction_type, status, created_at
`

type CreateTransactionParams struct {
	UserID          pgtype.UUID    `json:"user_id"`
	MerchantID      pgtype.UUID    `json:"merchant_id"`
	CoinsSpent      pgtype.Numeric `json:"coins_spent"`
	OriginalAmount  pgtype.Numeric `json:"original_amount"`
	TransactionType pgtype.Text    `json:"transaction_type"`
	Status          pgtype.Text    `json:"status"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.UserID,
		arg.MerchantID,
		arg.CoinsSpent,
		arg.OriginalAmount,
		arg.TransactionType,
		arg.Status,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MerchantID,
		&i.CoinsSpent,
		&i.OriginalAmount,
		&i.DiscountAmount,
		&i.FinalAmount,
		&i.TransactionType,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, user_id, merchant_id, coins_spent, original_amount, discount_amount, final_amount, transaction_type, status, created_at FROM transactions WHERE id = $1
`

func (q *Queries) GetTransactionByID(ctx context.Context, id pgtype.UUID) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MerchantID,
		&i.CoinsSpent,
		&i.OriginalAmount,
		&i.DiscountAmount,
		&i.FinalAmount,
		&i.TransactionType,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getUserDailySpending = `-- name: GetUserDailySpending :one
SELECT COALESCE(SUM(coins_spent), 0) as daily_spent
FROM transactions 
WHERE user_id = $1 
AND DATE(created_at) = CURRENT_DATE 
AND status = 'completed'
`

func (q *Queries) GetUserDailySpending(ctx context.Context, userID pgtype.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, getUserDailySpending, userID)
	var daily_spent interface{}
	err := row.Scan(&daily_spent)
	return daily_spent, err
}

const getUserMonthlySpending = `-- name: GetUserMonthlySpending :one
SELECT COALESCE(SUM(coins_spent), 0) as monthly_spent
FROM transactions 
WHERE user_id = $1 
AND EXTRACT(YEAR FROM created_at) = EXTRACT(YEAR FROM CURRENT_DATE)
AND EXTRACT(MONTH FROM created_at) = EXTRACT(MONTH FROM CURRENT_DATE)
AND status = 'completed'
`

func (q *Queries) GetUserMonthlySpending(ctx context.Context, userID pgtype.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, getUserMonthlySpending, userID)
	var monthly_spent interface{}
	err := row.Scan(&monthly_spent)
	return monthly_spent, err
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :exec
UPDATE transactions SET 
    status = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateTransactionStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status pgtype.Text `json:"status"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) error {
	_, err := q.db.Exec(ctx, updateTransactionStatus, arg.ID, arg.Status)
	return err
}
